#include <stdio.h>
#include <stdlib.h>

static char *term[] = { "%g0", "%o0", "%o1", "%o2", "%o3", "%g2", "%g3" };
static int regbits[] = { 0, 8, 9, 10, 11, 2, 3 };
static int tval[] = { 0x00, 0xf0, 0xcc, 0xaa };

#define NUM_TERMS (sizeof(tval)/sizeof(tval[0]))

#define COST_NOT 4
#define COST_OP  5

static struct { int left, op, right, cost, minterm; } q[258];
static int mt[256], mtpos[256];

static int tail=0, maxcost=0, minpos=0;

int genexp(int n, int targ, int scratch)
{
  int left, right, op;

  if(q[n].op<0) {
    if(targ) {
      printf("  0x%08x, /* mov %s,%s */\n",
	     0x80100000|(regbits[q[n].right])|(regbits[targ]<<25),
	     term[q[n].right], term[targ]);
      minpos++;
      return targ;
    } else return q[n].right;
  }
  if((op=q[n].op)!=3 && q[q[n].left].op==3) {
    op+=4;
    right = genexp(q[q[n].left].left, 0, scratch);
    left = genexp(q[n].right, 0, scratch&~(1<<right));
  } else if(op!=3 && q[q[n].right].op==3) {
    op+=4;
    left = genexp(q[n].left, 0, scratch);
    right = genexp(q[q[n].right].left, 0, scratch&~(1<<left));
  } else {
    left = genexp(q[n].left, 0, scratch);
    if(op!=3)
      right = genexp(q[n].right, 0, scratch&~(1<<left));
  }
  if(!targ) {
    if(!scratch) {
      fprintf(stderr, "Out of scratch registers!\n");
      exit(1);
    }
    for(targ=0; !((1<<targ)&scratch); targ++);
  }
  switch(op) {
  case 0:
    printf("  0x%08x, /* or %s,%s,%s */\n",
	   0x80100000|(regbits[left]<<14)|regbits[right]|(regbits[targ]<<25),
	   term[left], term[right], term[targ]);
    minpos++;
    break;
  case 1:
    printf("  0x%08x, /* and %s,%s,%s */\n",
	   0x80080000|(regbits[left]<<14)|regbits[right]|(regbits[targ]<<25),
	   term[left], term[right], term[targ]);
    minpos++;
    break;
  case 2:
    printf("  0x%08x, /* xor %s,%s,%s */\n",
	   0x80180000|(regbits[left]<<14)|regbits[right]|(regbits[targ]<<25),
	   term[left], term[right], term[targ]);
    minpos++;
    break;
  case 3:
    printf("  0x%08x, /* xor %s,-1,%s */\n",
	   0x80183fff|(regbits[left]<<14)|(regbits[targ]<<25),
	   term[left], term[targ]);
    minpos++;
    break;
  case 4:
    printf("  0x%08x, /* orn %s,%s,%s */\n",
	   0x80300000|(regbits[left]<<14)|regbits[right]|(regbits[targ]<<25),
	   term[left], term[right], term[targ]);
    minpos++;
    break;
  case 5:
    printf("  0x%08x, /* andn %s,%s,%s */\n",
	   0x80280000|(regbits[left]<<14)|regbits[right]|(regbits[targ]<<25),
	   term[left], term[right], term[targ]);
    minpos++;
    break;
  case 6:
    printf("  0x%08x, /* xnor %s,%s,%s */\n",
	   0x80380000|(regbits[left]<<14)|regbits[right]|(regbits[targ]<<25),
	   term[left], term[right], term[targ]);
    minpos++;
    break;
  }
  return targ;
}

void opgen(int s1, int s2, int op, int cost)
{
  q[tail].left=s1;
  q[tail].op=op;
  q[tail].right=s2;
  q[tail].cost=cost;
  switch(op) {
    case 0:
      q[tail].minterm=q[s1].minterm|q[s2].minterm;
      break;
    case 1:
      q[tail].minterm=q[s1].minterm&q[s2].minterm;
      break;
    case 2:
      q[tail].minterm=q[s1].minterm^q[s2].minterm;
      break;
    case 3:
      q[tail].minterm=q[s1].minterm^0xff;
      break;
    default:
      q[tail].minterm=q[tail].left;
      break;
  }
  if(mt[q[tail].minterm]<0)
    mt[q[tail].minterm]=tail++;
}

int main(int argc, char *argv[])
{
  int i, j, hibound;

  for(i=0; i<256; i++)
    mt[i]=-1;
  for(i=0; i<NUM_TERMS; i++)
    opgen(tval[i], i, -1, 0);

  while(tail<256) {
    maxcost++;
    hibound=tail;
    for(i=0; i<hibound; i++)
      if(q[i].cost+COST_NOT<=maxcost) {
	opgen(i, 0, 3, q[i].cost+COST_NOT);
        if(q[i].cost+5<=maxcost)
	  for(j=0; j<i && q[i].cost+q[j].cost+COST_OP<=maxcost; j++) {
	    opgen(i, j, 0, q[i].cost+q[j].cost+COST_OP);
	    opgen(i, j, 1, q[i].cost+q[j].cost+COST_OP);
	    opgen(i, j, 2, q[i].cost+q[j].cost+COST_OP);
	  }
      }
  }

  printf("/* This file is automatically generated.  Do not edit. */\n");
  printf("\n#include \"blitter.h\"\n\nstatic sparc_instr minstor[] = {\n");
  minpos=0;
  for(i=0; i<256; i++) {
    printf("  /* %02x */\n", i);
    mtpos[i]=minpos;
    genexp(mt[i], 4, 0x60);
    printf("  0,\n"); minpos++;
  }
  printf("};\n\nsparc_instr *minterms[] = {");
  for(i=0; i<256; i++) {
     if(!(i&3)) printf("\n  ");
     printf("&minstor[%d], ", mtpos[i]);
  }
  printf("\n};\n\n");
  return 0;
}

